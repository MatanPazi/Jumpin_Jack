/*
Reading from accelerometer LSM303
To-do:

*/

#include <Wire.h>

#define MOVE_AVG        8            // Must change value below as well!!
#define MOVE_AVG_POW    3            // MOVE_AVG = 2^(MOVE_AVG_POW)
#define ARR_SIZE        1000
#define ARDUINO         1
#define TEENSY          2
#define BOARD           ARDUINO

#if BOARD == ARDUINO
#define LED_BUILTIN 13
#else BOARD == TEENSY
#define LED_BUILTIN 11
#endif

const int LSM303 = 0x19;             // LSM303 I2C address, 0011001b
int AccX, AccY, AccZ;
int AccXArr[ARR_SIZE], AccYArr[ARR_SIZE], AccZArr[ARR_SIZE];
int Counter = 0;
int CounterArr = 0;
bool DataReady = 0;

void setup() {
  // Blink LED to indicate recording start
  delay(2000);
  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(5000);
  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW  
    
  Serial.begin(115200);
  Wire.begin();                      // Initialize comunication
  delay(5);
  
  // Configure the Accelerometer different registers
  Wire.beginTransmission(LSM303);
  Wire.write(0x20);                  // Talk to the CTRL_REG1_A register (20 hex)
  Wire.write(0x3F);                  // PM - Power on - Normal mode
                                     // DR - ODR = 1000 [Hz], LPF1  = 780 [Hz]
  Wire.endTransmission(true);
  
  delay(5);
  
  Wire.beginTransmission(LSM303);
  Wire.write(0x23);                  // Talk to the CTRL_REG4_A register (23 hex)
  Wire.write(0x30);                  // FS -  +/- 8g full scale range
  Wire.endTransmission(true);
  
  delay(5);
}

void loop() {

  // Do we need to divide the raw values? Doesn't seem so.
  while (Counter < ARR_SIZE) {
    Wire.beginTransmission(LSM303);
    Wire.write(0x27);                  // Register STATUS_REG_A, acceleration status.
    Wire.endTransmission(false);
    Wire.requestFrom(LSM303, 1, true); // Read 1 registers total
    DataReady = Wire.read() >> 7;      // We only care about the highest bit, ZYXOR
    while (!DataReady) {               // Wait untill the data of all 3 axes is ready
    }
    Wire.beginTransmission(LSM303);
    Wire.write(0x28);                  // Start with register OUT_X_L_A
    Wire.endTransmission(false);
    Wire.requestFrom(LSM303, 6, true); // Read 6 registers total, each axis value is stored in 2 registers
    // Data read is lower 8 bits then higher 8 bits (Actual resolution is 12 bits)
    AccX = (Wire.read() | Wire.read() << 8); // X-axis value
    AccY = (Wire.read() | Wire.read() << 8); // Y-axis value
    AccZ = (Wire.read() | Wire.read() << 8); // Z-axis value
    
    AccXArr[CounterArr] += AccX;
    AccYArr[CounterArr] += AccY;
    AccZArr[CounterArr] += AccZ;
    Counter++;
    if ((Counter % MOVE_AVG) == 0) {
      AccXArr[CounterArr] = AccX << MOVE_AVG_POW;
      AccYArr[CounterArr] = AccY << MOVE_AVG_POW;
      AccZArr[CounterArr] = AccZ << MOVE_AVG_POW;
      CounterArr++;
    }
  }
  
// Output on Serial plotter. Choose appropriate baud rate set above.  
  while (CounterArr >= 0)  {    
    Serial.print("AccX:");
    Serial.print(AccXArr[CounterArr]);
    Serial.print("\t");

    Serial.print("AccY:");
    Serial.print(AccYArr[CounterArr]);
    Serial.print(",");

    Serial.print("AccZ:");
    Serial.println(AccZArr[CounterArr]);
    Counter--;
  }
}
  
